#include <bits/stdc++.h>//خضر علي جنيدي , روان محمد عبد الله , زين رائد سليم

using namespace std;

// تعريف متجهات لتخزين القوائم المجاورة للبيان والبيان المعكوس
vector<int> adj[1000];
vector<int> adj_rev[1000];

// متجه لتخزين ترتيب العقد بعد أول DFS
vector<int> order;

// مصفوفة لتتبع العقد التي تم زيارتها
bool vis[1000];

// متغير لتتبع عدد العقد في البيان المتصل بقوه
int SUM;

// دالة DFS الأولى لتحديد ترتيب العقد
void dfs(int node)
{
 vis[node] = 1; // تعيين العقدة كمعالجة
 for (auto u : adj[node]) // المرور على جميع العقد المجاورة
 {
if (!vis[u]) // إذا لم تتم زيارة العقدة المجاورة
 dfs(u); // استدعاء DFS على العقدة المجاورة }
 order.push_back(node); // إضافة العقدة إلى الترتيب بعد معالجة جميع جيرانها
}
}
// دالة DFS الثانية لمعالجة البيان المعكوس
void dfs2(int node)
{
 vis[node] = 1; // تعيين العقدة كمعالجة
 SUM++; // زيادة عدد العقد في البيان المتصل بقوه 
for (auto u : adj_rev[node]) // المرور على جميع العقد المجاورة في البيان المعكوس
 {
if (!vis[u]) // إذا لم تتم زيارة العقدة المجاورة
dfs2(u); // استدعاء DFS على العقدة المجاورة
 }
}

int main()
{
 int n; // عدد العقد
 cin >> n;
 int m; // عدد الحواف
 cin >> m;

 // قراءة الحواف وبناء البيان و البيان المعكوس
 for (int i = 0; i < m; i++)
{
int x, y;
cin >> x >> y;
adj[x].push_back(y);// إضافة الحافة إلى البيان
adj_rev[y].push_back(x); // إضافة الحافة إلى  البيان المعكوس
 }

 // إجراء DFS الأول لتحديد ترتيب العقد
for (int i = 1; i <= n; i++)
 {
 if (!vis[i])
 dfs(i);
}
 
 // إعادة تعيين مصفوفة الزيارة
for (int i = 1; i <= n; i++)
vis[i] = 0;
 // إجراء DFS الثاني على البيان المعكوس بدءًا من العقدة الأخيرة في الترتيب
dfs2(order[order.size() - 1]);

// التحقق مما إذا كان البيان المتصل بقوه يحتوي على جميع العقد
if (SUM == n)
cout << "YES";//البيان متصل بقوه
 else
cout << "NO"; // البيان ليس متصل بقوه

return 0;
}
